### 문제유형

자료구조, 스택

### 풀이

1. 수 x를 하나씩 확인하며, 내림차순 혹은 같은 값의 x가 나오는 경우 스택에 삽입한다.

2. 더 큰 수(오름차순) x가 나왔을 때, x는 앞선 데이터에 대해서 오큰수가 될 수 있다.

- 따라서 스택의 pop()를 이용해 역방향으로 확인하면서 오큰수를 기록한다.
- 만약 역방향의 수가 x보다 크거나 같다면 멈추고, 해당 수부터 다시 내림차순/오름차순 여부를 확인한다.
- 동작 과정상 오른쪽으로 이동한 뒤에 다시 왼쪽으로(역방향으로)이동하는 것을 반복
- 시간복잡도 O(N)으로 해결가능

 

- 오큰수를 아직 찾지 못한 처리중인 원소를 담기위해 스택을 사용!!

```
11
3 2 1 10 9 5 4 8 15 11 13
```

list : 3 2 1 10 9 5 4 8 15 11 13

\1. 3을 스택에 넣는다.

| 수열   | **3** |      |      |      |      |      |      |      |      |      |      |
| ------ | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 오큰수 | -1    | -1   | -1   | -1   | -1   | -1   | -1   | -1   | -1   | -1   | -1   |

\2. 2를 스택에 넣는다.

| 수열   | **3** | **2** |      |      |      |      |      |      |      |      |      |
| ------ | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 오큰수 | -1    | -1    | -1   | -1   | -1   | -1   | -1   | -1   | -1   | -1   | -1   |

\3. 1을 스택에 넣는다.

| 수열   | **3** | **2** | **1** |      |      |      |      |      |      |      |      |
| ------ | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 오큰수 | -1    | -1    | -1    | -1   | -1   | -1   | -1   | -1   | -1   | -1   | -1   |

\4. top()보다 큰 수 10을 만났으므로, 역방향으로 하나씩 꺼내고 10을 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** |      |      |      |      |      |      |      |
| ------ | ----- | ----- | ----- | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | -1   | -1   | -1   | -1   | -1   | -1   | -1   |

\5. 이어서 9를 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | 5    | 4    | 8    | 15   | 11   | 13   |
| ------ | ----- | ----- | ----- | ------ | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | -1    | -1   | -1   | -1   | -1   | -1   | -1   |

\6. 이어서 5를 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | **5** | 4    | 8    | 15   | 11   | 13   |
| ------ | ----- | ----- | ----- | ------ | ----- | ----- | ---- | ---- | ---- | ---- | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | -1    | -1    | -1   | -1   | -1   | -1   | -1   |

\7. 이어서 4를 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | **5** | **4** | 8    | 15   | 11   | 13   |
| ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- | ---- | ---- | ---- | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | -1    | -1    | -1    | -1   | -1   | -1   | -1   |

\8. top()보다 큰 수 8을 만났으므로, 역방향으로 하나씩 꺼내고 8을 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | **5** | **4** | **8** | 15   | 11   | 13   |
| ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- | ----- | ---- | ---- | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | -1    | 8     | 8     | -1    | -1   | -1   | -1   |

\9. top()보다 큰 수 15를 만났으므로, 역방향으로 하나씩 꺼내고 15를 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | **5** | **4** | **8** | **15** | 11   | 13   |
| ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- | ----- | ------ | ---- | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | 15    | 8     | 8     | 15    | -1     | -1   | -1   |

\10. 이어서 11을 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | **5** | **4** | **8** | **15** | **11** | 13   |
| ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- | ----- | ------ | ------ | ---- |
| 오큰수 | 10    | 10    | 10    | -1     | 15    | 8     | 8     | 15    | -1     | -1     | -1   |

11.top()보다 큰 수 13을 만났으므로, 역방향으로 하나씩 꺼내고 13을 스택에 넣는다.

| 수열   | **3** | **2** | **1** | **10** | **9** | **5** | **4** | **8** | **15** | **11** | **13** |
| ------ | ----- | ----- | ----- | ------ | ----- | ----- | ----- | ----- | ------ | ------ | ------ |
| 오큰수 | 10    | 10    | 10    | -1     | 15    | 8     | 8     | 15    | -1     | 13     | -1     |

 





```java
import java.io.*;
import java.util.*;

public class Main {
    public static class node{
        int num; // 수
        int index; // 인덱스

        node(int num, int index){
            this.num = num;
            this.index = index;
        }
    }

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        Stack<node> stack = new Stack<>(); // (수, 인덱스) 형태로 삽입, 오큰수를 찾기 위해 사용
        int N = Integer.parseInt(br.readLine()); //수의 개수
        StringBuilder sb = new StringBuilder();

        int[] list = new int[N]; // 수열 데이터
        int[] arr = new int[N]; // 오큰수 배열

        Arrays.fill(arr, -1); // 오큰수 배열은 -1로 초기화

        st = new StringTokenizer(br.readLine());

        for (int i = 0; i < N; i++) {
            list[i] = Integer.parseInt(st.nextToken());
        }

        for(int i=0;i<N;i++)
        {
            int x = list[i]; // 수x를 하나씩 확인
            if(stack.size() == 0 || stack.peek().num >= x) // 내림차순인 경우
            {
                stack.push(new node(x,i)); //(수, 인덱스)형태로 스택에 삽입
            }
            else { // 오름차순인 경우 (더 큰 수)
                while (stack.size() > 0) // 역방향으로 하나씩 꺼낸다.
                {
                    node node = stack.pop();
                    int previous = node.num;
                    int index = node.index;
                    if(previous >= x) // 역방향의 수가 x보다 크거나 같은 이전 원소를 만났다면 다시 stack에 삽입하고 멈춘다.
                    {
                        stack.push(new node(previous,index));
                        break;
                    } else{ // 큰수일땐
                        arr[index] = x; //오큰수 기록
                    }
                }
                stack.push(new node(x,i)); //(수,인덱스) 형태로 삽입
            }

        }

        for(int x=0;x<N;x++)
        {
            sb.append(arr[x] + " ");
        }

        System.out.println(sb);
    }
}
```

